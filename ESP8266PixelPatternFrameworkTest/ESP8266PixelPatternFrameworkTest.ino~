/*******************************************************************
 *                                                                 *
 * Pixel Pattern Library ESP8266 Web Page Test                     *
 *                                                                 *
 * by Ross Butler  Oct. 2016                                       * 
 *                                                                 *
 *******************************************************************/

// /Users/ross/Library/Arduino15/packages/esp8266/tools/xtensa-lx106-elf-gcc/1.20.0-26-gb404fb9-2/bin/xtensa-lx106-elf-objdump  -d -S /var/folders/pr/80vsgp_575lbbzk8x5wbbd7m0000gn/T/arduino_build_722264/ESP8266PixelPatternFrameworkTest.ino.elf > xxx

#include "Esp8266WebPage.h"
#include <ESPDMX.h>
#include <ESP8266WiFi.h>
#include "FastLED.h"
#include "PixelPatternController.h"
#include "PatternSequence.h"
#include "pixelPatternFrameworkTypes.h"
#include "sequenceDefinition.h"
#include "ExternalControlSelector.h"
#include <vector>
#include <Wire.h>

extern "C" {
#include "ets_sys.h"  // ESP8266 timer and event stuff
}

using namespace pixelPattern;

enum class OperatingState {
    INIT_CONFIG,
    READ_CONFIG,
    INIT_PATTERNS,
    INIT_WEB_PAGE,
    RUN,
    FATAL_STOP
}; 

enum class StatusBlinkState {
    DIGIT_1,
    DIGIT_2,
    INTER_ELEMENT_DELAY,
    INTER_DIGIT_DELAY,
    INTER_STATUS_DELAY
};

//constexpr unsigned int statusBlink[][2] = {
//  {1, 1}, //  0:  normal operation
//  {2, 1}  //  1:  can't initialize configuration
//};

constexpr unsigned int status_normal = 0x11;
constexpr unsigned int status_initializing = 0x12;
constexpr unsigned int status_configInitFail = 0x21;

OperatingState opState;
unsigned int opStatus;

unsigned int fatalErrorCode;

ETSTimer statusBlinkTimer;
StatusBlinkState statusBlinkState;
constexpr unsigned int statusBlinkTimerIntervalMs = 100;

const String apPassword = "";
//const String apSsid = "";
const String apSsid = "PixPat";

//const String staSsid = "";    // set to empty string to disable station mode
//const String staPasskey = "";
const String staSsid = "trees";
const String staPasskey = "2083433061";
//const String staSsid = "XanaduShop";
//const String staPasskey = "xanadushop";

//const String staticIpAddress = "";
//const String gatewayAddress = "";
//const String subnetMask = "";
//const String dns1Address = "";
//const String dns2Address = "";
const String staticIpAddress = "192.168.76.99";
const String gatewayAddress = "192.168.76.3";
const String subnetMask = "255.255.255.0";
const String dns1Address = "192.168.76.3";
const String dns2Address = "0.0.0.0";

constexpr float vBatFullScale = (1023.0 * 12.42) / 690.0;  // input to voltage divider when A0 is 1023

#define STATUS_TEXT_UPDATE_INTERVAL_MS 1000

#define NUM_SECTIONS 5
#define MAX_SECTION_PATTERNS 21

#define LED_PIN 5
#define ANALOG_PIN A0
#define SECTION_0_DATA_PIN 12
#define SECTION_1_DATA_PIN 13
#define SECTION_2_DATA_PIN 14
#define SECTION_3_DATA_PIN 15
// Section 4 uses DMX.

#define SECTION_0_NUM_PIXELS 50
#define SECTION_1_NUM_PIXELS 50
#define SECTION_2_NUM_PIXELS 144
#define SECTION_3_NUM_PIXELS 50
#define SECTION_4_NUM_PIXELS 9

#define SECTION_3_NUM_PANELS 5

CRGB section0PixelArray[SECTION_0_NUM_PIXELS];
CRGB section1PixelArray[SECTION_1_NUM_PIXELS];
CRGB section2PixelArray[SECTION_2_NUM_PIXELS];
CRGB section3PixelArray[SECTION_3_NUM_PIXELS];
CRGB section4PixelArray[SECTION_4_NUM_PIXELS];

PixelSet sectionPixelSets[NUM_SECTIONS] = {
    {
        section0PixelArray,
        SECTION_0_NUM_PIXELS,
        0,    // skip pixels
        0,    // non-symmetrical pixels
        1,    // number of panels
        SECTION_0_NUM_PIXELS,  // number of pixels per panel (should be symmetrical / panels)
        128,  // foreground intensity scale factor
        64    // background intensity scale factor 
    },
    {
        section1PixelArray,
        SECTION_1_NUM_PIXELS,
        0,    // skip pixels
        0,    // non-symmetrical pixels
        1,    // number of panels
        SECTION_1_NUM_PIXELS,   // number of pixels per panel (should be symmetrical / panels)
        128,  // foreground intensity scale factor
        64    // background intensity scale factor 
    },
    {
        section2PixelArray,
        SECTION_2_NUM_PIXELS,
        0,    // skip pixels
        0,    // non-symmetrical pixels
        1,    // number of panels
        SECTION_2_NUM_PIXELS,   // number of pixels per panel (should be symmetrical / panels)
        64,   // foreground intensity scale factor
        32    // background intensity scale factor 
    },
    {
        section3PixelArray,
        SECTION_3_NUM_PIXELS,
        0,    // skip pixels
        0,    // non-symmetrical pixels
        SECTION_3_NUM_PANELS,    // number of panels
        SECTION_3_NUM_PIXELS / SECTION_3_NUM_PANELS, // number of pixels per panel (should be symmetrical / panels)
        128,  // foreground intensity scale factor
        64    // background intensity scale factor 
    },
    {
        section4PixelArray,
        SECTION_4_NUM_PIXELS,
        0,    // skip pixels
        0,    // non-symmetrical pixels
        1,    // number of panels
        SECTION_4_NUM_PIXELS,  // number of pixels per panel (should be symmetrical / panels)
        255,  // foreground intensity scale factor
        255   // background intensity scale factor 
    },
};

std::vector<Esp8266WebPage::Preset> presets = { 
  // name       pattern number for each section
  {"Ascending" ,  {1,  2,  3,  4,  5}},
  {"Descending",  {5,  4,  3,  2,  1}},
  {"Preset 3"  ,  {3,  3,  3,  3,  3}},
  {"Preset 4"  ,  {4,  4,  4,  4,  4}},
  {"Preset 5"  ,  {5,  5,  5,  5,  5}},
  {"All Off"   ,  {0,  0,  0,  0,  0}}
};

ExternalControlSelector sectionPatternSelector[NUM_SECTIONS];
PatternSequence* sectionPatternSequences[NUM_SECTIONS];
uint8_t sectionPatternSequenceIdxs[NUM_SECTIONS];

DMXESPSerial dmx;
Esp8266WebPage esp8266WebPage;
PixelPatternController patternController;



ETSTimerFunc statusBlinkTimerCallback(void *arg)
{
  static unsigned int intervalCount;
  static StatusBlinkState returnState;
  static bool ledIsOn;

  if (++intervalCount == 5) {
    ledIsOn != ledIsOn;
    digitalWrite(LED_PIN, ledIsOn ? HIGH : LOW);
    intervalCount = 0;
  }

/*
  switch(statusBlinkState)

    case DIGIT_1:
      break;

    case DIGIT_2:
      break;

    case INTER_ELEMENT_DELAY:
      break;

    case INTER_DIGIT_DELAY:
      break;

    case INTER_STATUS_DELAY:
      break;
  }
*/
}


void initHardware()
{
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  //Serial.println("hardware init done");
}


void initTimers()
{
//  ets_timer_setfn(&statusBlinkTimer, &statusBlinkTimerCallback, &statusBlinkTimerArg);
//  ets_timer_arm_new(&statusBlinkTimer, statusBlinkTimerIntervalMs, 1, 1);   // repeat = 1, isMsTimer = 1
  os_timer_init
  os_timer_setfn(&statusBlinkTimer, &statusBlinkTimerCallback, NULL);
  os_timer_arm(&statusBlinkTimer, statusBlinkTimerIntervalMs, 1);   // repeat = 1
}


void initPatterns()
{
  // 10 pixels/m 12 V white strips from HolidayCoro 11/2015:  WS2812B, BRG
  // 60? pixels/m 5 V white 8-pixel strip gift from E11 2015:  WS2812B, GRB
  // Brilliant Bulb (tm) pixel strawberry strings:  WS2812B, RGB 
  FastLED.addLeds<WS2812B, SECTION_0_DATA_PIN, GRB>(section0PixelArray, SECTION_0_NUM_PIXELS);
  FastLED.addLeds<WS2812B, SECTION_1_DATA_PIN, GRB>(section1PixelArray, SECTION_1_NUM_PIXELS);
  FastLED.addLeds<WS2812B, SECTION_2_DATA_PIN, GRB>(section2PixelArray, SECTION_2_NUM_PIXELS);
  FastLED.addLeds<WS2812B, SECTION_3_DATA_PIN, GRB>(section3PixelArray, SECTION_3_NUM_PIXELS);

  dmx.init();

  sectionPatternSequences[0] = new PatternSequence(section0PatternDefs, sizeof(section0PatternDefs) / sizeof(PatternDef), &sectionPatternSelector[0]);
  sectionPatternSequences[1] = new PatternSequence(section1PatternDefs, sizeof(section1PatternDefs) / sizeof(PatternDef), &sectionPatternSelector[1]);
  sectionPatternSequences[2] = new PatternSequence(section2PatternDefs, sizeof(section2PatternDefs) / sizeof(PatternDef), &sectionPatternSelector[2]);
  sectionPatternSequences[3] = new PatternSequence(section3PatternDefs, sizeof(section3PatternDefs) / sizeof(PatternDef), &sectionPatternSelector[3]);
  sectionPatternSequences[4] = new PatternSequence(section4PatternDefs, sizeof(section4PatternDefs) / sizeof(PatternDef), &sectionPatternSelector[4]);

  for (int sectionIdx = 0; sectionIdx < NUM_SECTIONS; ++sectionIdx) {
    sectionPatternSequenceIdxs[sectionIdx] =
      patternController.addPatternSequence(sectionPatternSequences[sectionIdx], &sectionPixelSets[sectionIdx]);
    sectionPatternSelector[sectionIdx].setPatternNum(255);
  }

  patternController.enableStatusLed(LED_PIN);
  patternController.init();

  Serial.println("pattern init done");
}


void initWebPage()
{
  if (staticIpAddress != "") {
    esp8266WebPage.setStaticIpAddress(staticIpAddress, gatewayAddress, subnetMask, dns1Address, dns2Address);
  }

  if (staSsid != "") {
    esp8266WebPage.setSta(staSsid, staPasskey);
  }

  if (apSsid != "") {
    esp8266WebPage.setAp(apSsid, apPassword);
  }

  for (int sectionIdx = 0; sectionIdx < NUM_SECTIONS; ++sectionIdx) {
    esp8266WebPage.addPatternSequence(sectionPatternSequences[sectionIdx]);
  }

  esp8266WebPage.addPreset(presets);

  esp8266WebPage.init();

  Serial.println("wifi init done");
}


void updateStatusText()
{
  float a0 = analogRead(ANALOG_PIN);
  float vBat = vBatFullScale * a0 / 1024.0;
  String statusText = "<h3>Battery: " + String(vBat, 1) + " V</h3>";
  esp8266WebPage.setStatusText(statusText);
}


void writeToDmxLeds()
{
  for (int i = 0, dmxCh = 1; i < SECTION_4_NUM_PIXELS; ++i) {
    dmx.write(dmxCh++, section4PixelArray[i].red);
    dmx.write(dmxCh++, section4PixelArray[i].green);
    dmx.write(dmxCh++, section4PixelArray[i].blue);
    dmx.update();
  }
}


void setup() 
{
  // Let everything settle down after a rough power-up,
  // and wait a while to make sure power remains applied.
  delay(1000);

  initHardware();

  opStatus = status_initializing;
  statusBlinkState = INTER_STATUS_DELAY;

  initTimers();

  // The battery voltage should be a good enough seed for the random number generator.
  randomSeed(analogRead(ANALOG_PIN));

  opState = INIT_CONFIG;
}


void loop() 
{
  static unsigned long nextStatusTextUpdateMs;

  switch(opState) {

    case INIT_CONFIG:
      opState = READ_CONFIG;
      break;

    case READ_CONFIG:
      opState = INIT_PATTERNS;
      break;

    case INIT_PATTERNS:
      initPatterns();
      opState = INIT_WEB_PAGE;
      break;

    case INIT_WEB_PAGE:
      initWebPage();
      opState = RUN;
      break;

    case RUN:
      unsigned long now = millis();
      if (now - nextStatusTextUpdateMs >= STATUS_TEXT_UPDATE_INTERVAL_MS) {
        nextStatusTextUpdateMs = now + STATUS_TEXT_UPDATE_INTERVAL_MS;
        updateStatusText();
      }
      esp8266WebPage.doWiFi();
      patternController.update();
      if (patternController.getUpdateLeds(sectionPatternSequenceIdxs[4])) {
        writeToDmxLeds();
      }
      break;

    case FATAL_STOP:
      // Do nothing.  Just let the status light blink--if it can.
  }

}


